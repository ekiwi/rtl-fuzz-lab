#!/bin/bash
# This script automates running the AFL fuzz script.
# Takes in the desired output folder and number of minutes to fuzz.

if ! [ $# -eq 4 ] ; then
  echo "Incorrect number of arguments!. Must pass in arguments: OUTPUT_FOLDER MINUTES HARNESS FIRRTL" >&2
  exit 1
fi

OUT=$1
minutes=$2
harness=$3
FIRRTL=$4

# Performs checks on inputted command line arguments
if [ -d ${OUT} ]; then
  echo "WARNING! DESIRED OUTPUT FOLDER WOULD BE OVERWRITTEN: ${OUT}. Exiting to preserve fuzzing results."
  exit 1
fi

re='^[0-9]+$'
if ! [[ $minutes =~ $re ]] ; then
   echo "MINUTES argument must be a number" >&2
   exit 1
fi

# Add 5 seconds to fuzzing time to account for startup time to fuzzing
((seconds=$minutes*60))
((shifted=$seconds+5))
time_string=${shifted}s

# Creates jar file to allow execution of Scala code using terminal commands
sbt assembly

# Calls AFLDriver to setup fuzzing
echo ""
echo "Calling AFLDriver on: ${FIRRTL} input a2j j2a ${harness}"
echo ""
# Option 1 (preferred due to slightly better memory usage and possible slightly better execution speed)
java -cp target/scala-2.12/chiseltest-assembly-0.5-SNAPSHOT.jar chiseltest.fuzzing.afl.AFLDriver ${FIRRTL} input a2j j2a ${harness} &
sleep 13s
# Option 2
#sbt "runMain chiseltest.fuzzing.afl.AFLDriver src/test/resources/fuzzing/TLI2C.fir input a2j j2a TLUL" &
#sleep 20s


# Calls AFL to fuzz for the specified period of time
timeout $time_string ~/AFL/afl-fuzz -i seeds -o temp_out -f input -- ./fuzzing/afl-proxy a2j j2a log

# Moves result to desired location. Wait until end_time file is generated by AFLDriver.
while ! [ -f "temp_out/end_time" ]; do
  sleep 1
done

mv temp_out ${OUT}

# Generate coverage results with CoverageAnalysis.scala
java -cp target/scala-2.12/chiseltest-assembly-0.5-SNAPSHOT.jar chiseltest.fuzzing.coverage.CoverageAnalysis ${FIRRTL} ${OUT} ${harness}

exit 0
